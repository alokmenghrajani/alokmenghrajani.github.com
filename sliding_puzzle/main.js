/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./confetti.js":
/*!*********************!*\
  !*** ./confetti.js ***!
  \*********************/
/***/ ((module) => {

eval("/**\n * Code based on https://www.python2.net/questions-336875.htm which might\n * have been based on https://freesoft.dev/program/153351919 and\n * https://github.com/wesleycho/confetti.js.\n *\n * I removed parts of the code I didn't need and made some minor refactor.\n */\n\nclass Confetti {\n\tstatic frameInterval = 15;\t//the confetti animation frame interval in milliseconds\n\tstatic colors = [\"rgb(30,144,255)\", \"rgba(107,142,35)\", \"rgba(255,215,0)\", \"rgba(255,192,203)\", \"rgba(106,90,205)\", \"rgba(173,216,230)\", \"rgba(238,130,238)\", \"rgba(152,251,152)\", \"rgba(70,130,180)\", \"rgba(244,164,96)\", \"rgba(210,105,30)\", \"rgba(220,20,60)\"];\n\n\tconstructor(target, difficulty) {\n\t\tthis.isRunning = false;\n\t\tthis.particles = [];\n\t\tthis.waveAngle = 0;\n\t\tthis.context = null;\n\t\tthis.count = 0;\n\t}\n\n\treset(particle, width, height) {\n\t\tparticle.color = Confetti.colors[(Math.random() * Confetti.colors.length)|0];\n\t\tparticle.x = Math.random() * width;\n\t\tparticle.y = Math.random() * height - height;\n\t\tparticle.diameter = Math.random() * 10 + 5;\n\t\tparticle.tilt = Math.random() * 10 - 10;\n\t\tparticle.tiltAngleIncrement = Math.random() * 0.07 + 0.05;\n\t\tparticle.tiltAngle = Math.random() * Math.PI;\n\t\treturn particle;\n\t}\n\n\tgo() {\n\t\tif (this.particles.length == 0) {\n\t\t\tthis.context.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\t\t} else {\n\t\t\tthis.context.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\t\t\tthis.update();\n\t\t\tthis.draw(this.context);\n\t\t\twindow.requestAnimationFrame(() => this.go());\n\t\t}\n\t}\n\n\tstart(timeout) {\n\t\tconst width = window.innerWidth;\n\t\tconst height = window.innerHeight;\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tcanvas.setAttribute(\"id\", \"confetti-canvas\");\n\t\tcanvas.setAttribute(\"style\", \"display:block;z-index:999999;pointer-events:none;position:fixed;top:0\");\n\t\tdocument.body.prepend(canvas);\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\twindow.addEventListener(\"resize\", function() {\n\t\t\tcanvas.width = window.innerWidth;\n\t\t\tcanvas.height = window.innerHeight;\n\t\t}, true);\n\t\tthis.context = canvas.getContext(\"2d\");\n\t\tthis.count = Math.sqrt(canvas.width * canvas.height) / 4;\n\n\t\twhile (this.particles.length < this.count) {\n\t\t\tthis.particles.push(this.reset({}, width, height));\n\t\t}\n\t\tthis.isRunning = true;\n\t\tthis.go();\n\t\tif (timeout) {\n\t\t\twindow.setTimeout(() => this.isRunning = false, timeout);\n\t\t}\n\t}\n\n\tdraw(context) {\n\t\tfor (let i = 0; i < this.particles.length; i++) {\n\t\t\tconst particle = this.particles[i];\n\t\t\tcontext.beginPath();\n\t\t\tcontext.lineWidth = particle.diameter;\n\t\t\tconst x2 = particle.x + particle.tilt;\n\t\t\tconst x = x2 + particle.diameter / 2;\n\t\t\tconst y2 = particle.y + particle.tilt + particle.diameter / 2;\n\t\t\tcontext.strokeStyle = particle.color;\n\t\t\tcontext.moveTo(x, particle.y);\n\t\t\tcontext.lineTo(x2, y2);\n\t\t\tcontext.stroke();\n\t\t}\n\t}\n\n\tupdate() {\n\t\tconst width = window.innerWidth;\n\t\tconst height = window.innerHeight;\n\t\tthis.waveAngle += 0.01;\n\t\tfor (let i = 0; i < this.particles.length; i++) {\n\t\t\tlet particle = this.particles[i];\n\t\t\tif (!this.isRunning && particle.y < -15) {\n\t\t\t\tparticle.y = height + 100;\n\t\t\t} else {\n\t\t\t\tparticle.tiltAngle += particle.tiltAngleIncrement;\n\t\t\t\tparticle.x += Math.sin(this.waveAngle) - 0.5;\n\t\t\t\tparticle.y += (Math.cos(this.waveAngle) + particle.diameter + 2) * 0.5;\n\t\t\t\tparticle.tilt = Math.sin(particle.tiltAngle) * 15;\n\t\t\t}\n\t\t\tif (particle.x > width + 20 || particle.x < -20 || particle.y > height) {\n\t\t\t\tif (this.isRunning && this.particles.length <= this.count) {\n\t\t\t\t\tthis.reset(particle, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tthis.particles.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = Confetti\n\n\n//# sourceURL=webpack://sliding_puzzle/./confetti.js?");

/***/ }),

/***/ "./html-ui.js":
/*!********************!*\
  !*** ./html-ui.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {positiveMod: positiveMod} = __webpack_require__(/*! ./utils.js */ \"./utils.js\");\nconst Confetti = __webpack_require__(/*! ./confetti.js */ \"./confetti.js\");\n\n__webpack_require__.g.conf = Confetti;\n\n/**\n * Code to create html nodes and handle interaction via mouse/touch gestures.\n */\nclass HtmlUI {\n  constructor(puzzle, board, goal) {\n    this.puzzle = puzzle;\n    this.rows = this.puzzle.rows;\n    this.cols = this.puzzle.cols;\n    this.board = board;\n    this.goal = goal;\n    this.dragging = null;\n    // use pointerId to disable multitouch events.\n    this.pointerId = null;\n    this.dragStart = [0, 0];\n\n    // Setup colormap. Letters map to arbitrary colors, numbers map to a\n    // gradient.\n    this.colorMap = {};\n    this.colorMap[\"A\"] = \"#b7e5dd\";\n    this.colorMap[\"B\"] = \"#9a86a4\";\n    this.colorMap[\"C\"] = \"#b1bce6\";\n    const md = Math.hypot(this.rows, this.cols);\n\n    // In general, i maps to colum indexes and j maps to row indexes.\n    for (let i=0; i<this.cols; i++) {\n      for (let j=0; j<this.rows; j++) {\n        const n = j * this.cols + i + 1;\n        const d = Math.hypot(this.cols - i, this.rows - j) / md;\n        const red = 0x00 + (0xe0 - 0x00) * d;\n        const green = 0x40 + (0xe0 - 0x40) * d;\n        const blue = 0x70 + (0xe0 - 0x70) * d;\n        const color = 'rgba(' + [red, green, blue].join() + \")\";\n        this.colorMap[n] = color;\n      }\n    }\n\n    this.createGrid();\n    this.createGoal();\n    this.initKeys();\n\n    document.onpointermove = (ev) => this.handleMove(ev);\n    document.onpointerup = (ev) => this.handleEnd(ev);\n    document.onkeydown = (ev) => this.handleKey(ev);\n  }\n\n  createGrid() {\n    this.offsets = {}; // tracks divs => offsets\n    this.divs = {}; // tracks offsets => divs\n\n    const r = [];\n    // We add cells in the [-n, 2*n) range to make wrapping easier.\n    for (let i=-this.cols; i<2*this.cols; i++) {\n      for (let j=-this.rows; j<2*this.rows; j++) {\n        r.push(this.createCell(i, j, this.puzzle.state[positiveMod(j, this.rows)][positiveMod(i, this.cols)]));\n      }\n    }\n    this.board.replaceChildren(...r);\n\n    const solved = this.puzzle.solved();\n    this.board.className = solved ? \"solved\" : \"unsolved\";\n    if (solved) {\n      new Confetti().start(10000);\n    }\n  }\n\n  createCell(x, y, label) {\n    const div = document.createElement(\"div\");\n    div.innerText = label;\n    div.style.left = this.offsetToPercentage(x,this.cols);\n    div.style.top = this.offsetToPercentage(y,this.rows);\n    div.style.width = (100 / this.cols) + \"%\";\n    div.style.height = (100 / this.rows) + \"%\";\n    div.style.backgroundColor = this.colorMap[label];\n    div.id = \"cell_\" + this.offsetToStr(x, y);\n\n    // UI events\n    div.onpointerdown = (ev) => this.handleStart(ev);\n\n    this.offsets[div.id] = [x, y];\n    this.divs[this.offsetToStr(x, y)] = div;\n\n    return div;\n  }\n\n  offsetToPercentage(n, m) {\n    return (n * 100 / m) + \"%\";\n  }\n\n  offsetToStr(x, y) {\n    return x * 100 + y;\n  }\n\n  createGoal() {\n    for (let i=0; i<this.cols; i++) {\n      for (let j=0; j<this.rows; j++) {\n        this.createGoalCell(i, j, this.puzzle.target[j][i])\n      }\n    }\n  }\n\n  createGoalCell(x, y, label) {\n    const div = document.createElement(\"div\");\n    div.innerText = label;\n    div.style.left = this.offsetToPercentage(x, this.cols);\n    div.style.top = this.offsetToPercentage(y, this.rows);\n    div.style.width = (100 / this.cols) + \"%\";\n    div.style.height = (100 / this.rows) + \"%\";\n    div.style.backgroundColor = this.colorMap[label];\n    this.goal.appendChild(div);\n  }\n\n  handleStart(ev) {\n    if (this.dragging != null) {\n      // We got a handleStart while already dragging. This can happen in various\n      // edge cases. The easiest is to ignore the event\n      return false;\n    }\n\n    if (this.puzzle.solved()) {\n      // Disallow making moves once the puzzle is solved.\n      return false;\n    }\n\n    // record element's starting position\n    const r = board.getBoundingClientRect();\n\n    this.dragStart = [ev.clientX - r.x, ev.clientY - r.y];\n    this.pointerId = ev.pointerId;\n    this.dragging = ev.srcElement;\n    ev.preventDefault();\n    return false;\n  }\n\n  handleMove(ev) {\n    if (this.dragging == null) {\n      return false;\n    }\n    if (ev.pointerId != this.pointerId) {\n      return false;\n    }\n\n    // calculate how much the mouse has moved from it's initial position\n    const r = this.board.getBoundingClientRect();\n\n    const x = ev.clientX - r.x;\n    const y = ev.clientY - r.y;\n    let deltaX = x - this.dragStart[0];\n    let deltaY = y - this.dragStart[1];\n\n    // Prevent dragging too far in any direction\n    const maxX = this.offsetToX(this.cols - 0.5);\n    if (deltaX > maxX) {\n      deltaX = maxX;\n    }\n    if (deltaX < -maxX) {\n      deltaX = -maxX;\n    }\n    const maxY = this.offsetToY(this.rows - 0.5);\n    if (deltaY > maxY) {\n      deltaY = maxY;\n    }\n    if (deltaY < -maxY) {\n      deltaY = -maxY;\n    }\n\n    // reset the nodes since we might be switching from dragging horizontally to\n    // vertically or vice-versa.\n    this.resetNodes();\n\n    // figure out which axis we are dragging on\n    if (Math.abs(deltaX) > Math.abs(deltaY)) {\n      // Grab all the nodes which need to move\n      const rows = this.puzzle.rowGroup(this.offsets[this.dragging.id][1]);\n      const nodes = rows.flatMap(row => this.findHorzNodes(row));\n      nodes.forEach(el => {\n        // TODO: would be cleaner to use percentages. It doesn't matter much as\n        // we rebuild the grid at the end of the grad event.\n        el.style.left = this.offsetToX(this.offsets[el.id][0]) + deltaX;\n      });\n    } else {\n      // Grab all the nodes on the same column\n      const cols = this.puzzle.colGroup(this.offsets[this.dragging.id][0]);\n      const nodes = cols.flatMap(col => this.findVertNodes(col));\n      nodes.forEach(el => {\n        // TODO: would be cleaner to use percentages. It doesn't matter much as\n        // we rebuild the grid at the end of the grad event.\n        el.style.top = this.offsetToY(this.offsets[el.id][1]) + deltaY;\n      });\n    }\n    ev.preventDefault();\n    return false;\n  }\n\n  handleEnd(ev) {\n    if (this.dragging == null) {\n      // This can happen if the initial mouse down happens outside the play\n      // area. Simplest to ignore.\n      return false;\n    }\n\n    // TODO: refactor with above\n\n    // calculate how much the mouse has moved from it's initial position\n    // assumption: all 4 borders have the same width.\n    const r = this.board.getBoundingClientRect();\n    const x = ev.clientX - r.x;\n    const y = ev.clientY - r.y;\n    let deltaX = x - this.dragStart[0];\n    let deltaY = y - this.dragStart[1];\n\n    // Prevent dragging too far in any direction\n    const maxX = this.offsetToX(this.cols - 0.5);\n    if (deltaX > maxX) {\n      deltaX = maxX;\n    }\n    if (deltaX < -maxX) {\n      deltaX = -maxX;\n    }\n    const maxY = this.offsetToY(this.rows - 0.5);\n    if (deltaY > maxY) {\n      deltaY = maxY;\n    }\n    if (deltaY < -maxY) {\n      deltaY = -maxY;\n    }\n\n    // reset the nodes since we might be switching from dragging horizontally to\n    // vertically or vice-versa.\n    this.resetNodes();\n\n    // figure out which axis we are dragging on\n    if (Math.abs(deltaX) > Math.abs(deltaY)) {\n      // round deltaX\n      const r = this.board.getBoundingClientRect();\n      deltaX = Math.round(deltaX * this.cols / r.width);\n      this.puzzle.moveHorz(this.offsets[this.dragging.id][1], deltaX);\n    } else {\n      // round deltaY\n      const r = this.board.getBoundingClientRect();\n      deltaY = Math.round(deltaY * this.rows / r.height);\n      this.puzzle.moveVert(this.offsets[this.dragging.id][0], deltaY);\n    }\n\n    this.createGrid();\n    this.dragging = null;\n    ev.preventDefault();\n    return false;\n  }\n\n  initKeys() {\n    // [hv, idx, n] means\n    //   hv: 0 for horizontal, 1 for vertical\n    //   idx: the index of row or column\n    //   n: the move count\n    this.keys = {};\n    for (let i = 0; i < this.cols; i++) {\n      this.keys[49 + i] = [1, i, 1];\n    }\n    // TGBYHN\n    const hkeys = [84, 71, 66, 89, 72, 78];\n    for (let i = 0; i < this.rows; i++) {\n      this.keys[hkeys[i]] = [0, i, 1];\n    }\n  }\n\n  handleKey(ev) {\n    const funs = [\n      (a, b) => { this.puzzle.moveHorz(a, b); },\n      (a, b) => { this.puzzle.moveVert(a, b); }\n    ];\n    if (ev.keyCode in this.keys) {\n      let move = this.keys[ev.keyCode];\n      let k = 1;\n      if (ev.shiftKey) {\n        k = -1;\n      }\n      funs[move[0]](move[1], k * move[2]);\n    } else {\n      return;\n    }\n    this.createGrid();\n    ev.preventDefault();\n  }\n\n  resetNodes() {\n    const rows = this.puzzle.rowGroup(this.offsets[this.dragging.id][1]);\n    let nodes = rows.flatMap(row => this.findHorzNodes(row));\n    nodes.forEach(el => el.style.left = this.offsetToX(this.offsets[el.id][0]));\n\n    const cols = this.puzzle.colGroup(this.offsets[this.dragging.id][0]);\n    nodes = cols.flatMap(col => this.findVertNodes(col));\n    nodes.forEach(el => el.style.top = this.offsetToY(this.offsets[el.id][1]));\n  }\n\n  findHorzNodes(offset) {\n    const r = [];\n    for (let i=-this.cols; i<2*this.cols; i++) {\n      r.push(this.divs[this.offsetToStr(i, offset)])\n    }\n    return r;\n  }\n\n  findVertNodes(offset) {\n    const r = [];\n    for (let j=-this.rows; j<2*this.rows; j++) {\n      r.push(this.divs[this.offsetToStr(offset, j)])\n    }\n    return r;\n  }\n\n  offsetToX(n) {\n    const border = (this.board.offsetWidth - this.board.clientWidth);\n    const r = this.board.getBoundingClientRect();\n    return n * (r.width-border)/this.cols;\n  }\n\n  offsetToY(n) {\n    const border = (this.board.offsetHeight - this.board.clientHeight);\n    const r = this.board.getBoundingClientRect();\n    return n * (r.height-border)/this.rows;\n  }\n}\n\nmodule.exports = HtmlUI\n\n\n//# sourceURL=webpack://sliding_puzzle/./html-ui.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * The code maintains an internal model and a view (html nodes). Dragging works\n * on the view, but once the drag ends, the final move is computed and performed\n * on the model. The model is then used to rebuild the view to ensure both are\n * in sync. Creating/throwing away a small number of html nodes is cheap vs\n * ensuring that the view and model match up. This allows the model to only care\n * about a 4x4 grid, while the view can have extra html nodes to give the\n * illusion of wrapping around.\n */\n\nconst {Puzzle: Puzzle, Difficulty: Difficulty} = __webpack_require__(/*! ./puzzle.js */ \"./puzzle.js\");\nconst HtmlUI = __webpack_require__(/*! ./html-ui.js */ \"./html-ui.js\");\n\nfunction positionBoards() {\n  const r = __webpack_require__.g.container.getBoundingClientRect();\n  const board = __webpack_require__.g.board;\n  const goal = __webpack_require__.g.goal;\n\n  if (r.width > r.height) {\n    // board size must be <= r.height and 66% of r.width\n    const s = (Math.min(r.height, 0.66 * (r.width - 10)))|0;\n    board.style.width = s;\n    board.style.height = s;\n    goal.style.width = s/3;\n    goal.style.height = s/3;\n    goal.style.left = s + 10;\n    goal.style.top = 2*s/3;\n  } else {\n    // board size must be <= r.width and 66% of r.height\n    const s = (Math.min(r.width, 0.66 * (r.height - 10)))|0;\n    board.style.width = s;\n    board.style.height = s;\n    goal.style.width = s/3;\n    goal.style.height = s/3;\n    goal.style.left = 2*s/3;\n    goal.style.top = s + 10;\n  }\n}\n\nwindow.onload = () => positionBoards();\nwindow.onresize = () => positionBoards();\npositionBoards();\n\n// characters used for patterns\nconst digits = \"ABCDEFGHIJK\";\n\n// mkPuzzle\n//   rows: the number of rows\n//   cols: the number of cols\n//   pattern: 0 if no pattern, otherwise the size of the pattern. 2\n//     means two colors (A and B). 3, three (A, B and C) etc.\n//   height: the number of grouped rows when moving\n//   width: the number of grouped columns when moving\nfunction mkPuzzle(rows, cols, pattern, height, width) {\n  const arr = new Array(rows);\n  for (let i = 0; i < rows; i++) {\n    arr[i] = new Array(cols);\n    for (let j = 0; j < cols; j++) {\n      let cell;\n      if (pattern == 0) {\n        cell = cols * i + j + 1;\n      } else {\n        cell = digits[(i + j) % pattern];\n      }\n      arr[i][j] = cell;\n    }\n  }\n  const difficulty = new Difficulty(height, width);\n  const puzzle = new Puzzle(arr, difficulty);\n  puzzle.shuffle(100);\n  return puzzle;\n}\n\nfunction loadLevel(level) {\n  let puzzle;\n  let text;\n  switch (level) {\n    case \"easy\":\n      puzzle = mkPuzzle(4, 4, 2, 1, 1);\n      text = \"Easy\";\n      break;\n    case \"medium\":\n      puzzle = mkPuzzle(4, 4, 0, 1, 1);\n      text = \"Medium\";\n      break;\n    case \"hard\":\n      puzzle = mkPuzzle(4, 4, 0, 2, 2);\n      text = \"Hard\";\n      break;\n    case \"6x6 easy\":\n      puzzle = mkPuzzle(6, 6, 0, 2, 2);\n      text = \"6x6 easy\";\n      break;\n    case \"6x6 medium\":\n      puzzle = mkPuzzle(6, 6, 3, 3, 3);\n      text = \"6x6 medium\";\n      break;\n    case \"6x6 hard\":\n      puzzle = mkPuzzle(6, 6, 0, 3, 3);\n      text = \"6x6 hard\";\n      break;\n  }\n  new HtmlUI(puzzle, board, goal);\n  __webpack_require__.g.footer.innerText = \"Current level: \" + text;\n}\n\n// default easy\nloadLevel(\"easy\");\n\n__webpack_require__.g.showInstructions.onclick = (e) => {\n  document.body.classList.add(\"hide\");\n  __webpack_require__.g.instr.classList.add(\"enabled\");\n}\n\n__webpack_require__.g.instr.onclick = () => {\n  document.body.classList.remove(\"hide\");\n  __webpack_require__.g.instr.classList.remove(\"enabled\");\n}\n\n__webpack_require__.g.showLevels.onclick = () => {\n  document.body.classList.add(\"hide\");\n  __webpack_require__.g.levels.classList.add(\"enabled\");\n}\n\n__webpack_require__.g.easy.onclick = () => loadLevel(\"easy\");\n__webpack_require__.g.medium.onclick = () => loadLevel(\"medium\");\n__webpack_require__.g.hard.onclick = () => loadLevel(\"hard\");\n__webpack_require__.g.gen_6x6_easy.onclick = () => loadLevel(\"6x6 easy\");\n__webpack_require__.g.gen_6x6_medium.onclick = () => loadLevel(\"6x6 medium\");\n__webpack_require__.g.gen_6x6_hard.onclick = () => loadLevel(\"6x6 hard\");\n\n__webpack_require__.g.levels.onclick = () => {\n  document.body.classList.remove(\"hide\");\n  __webpack_require__.g.levels.classList.remove(\"enabled\");\n}\n\n\n//# sourceURL=webpack://sliding_puzzle/./index.js?");

/***/ }),

/***/ "./puzzle.js":
/*!*******************!*\
  !*** ./puzzle.js ***!
  \*******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {positiveMod, randInt} = __webpack_require__(/*! ./utils.js */ \"./utils.js\");\n\n/**\n * Core of the puzzle. This class tracks the current state of the grid, handles\n * shuffling, checking whether we are done, etc.\n */\nclass Puzzle {\n  constructor(target, difficulty) {\n    this.target = target;\n    // Use a roundtrip via JSON to clone the target array\n    this.state = JSON.parse(JSON.stringify(target));\n    this.rows = this.state.length;\n    this.cols = this.state[0].length;\n    this.difficulty = difficulty;\n  }\n\n  shuffle(n) {\n    // if n>100, random moves should be enough to get an interesting start\n    // position. The advantage of using random moves is that it guarantees that\n    // the resulting board is solvable. The downside is that not all board\n    // positions will be equally likely to show up.\n    for (let i = 0; i < n; i++) {\n\n      // pick -1 or 1\n      const dir = 2 * randInt(2) - 1;\n\n      if (Math.random() > 0.5) {\n        // pick a number between 0 .. rows-1\n        const pos = randInt(this.rows);\n        this.moveHorz(pos, dir);\n      } else {\n        // pick a number between 0 .. cols-1\n        const pos = randInt(this.cols);\n        this.moveVert(pos, dir);\n      }\n    }\n  }\n\n  solved() {\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (this.state[i][j] != this.target[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return the group of rows or cols to moves.\n   */\n  rowColGroup(i, h) {\n    const idx = Math.floor(i / h);\n    const group = [];\n    for (let j = 0; j < h; j++) {\n      group[j] = idx * h + j;\n    }\n    return group;\n  }\n\n  rowGroup(i) {\n    return this.rowColGroup(i, this.difficulty.height);\n  }\n\n  colGroup(j) {\n    return this.rowColGroup(j, this.difficulty.width);\n  }\n\n  moveHorz(y, dir) {\n    const rows = this.rowGroup(y);\n    rows.forEach(row => this.moveSingleRowHorz(row, dir));\n  }\n\n  moveSingleRowHorz(i, dir) {\n    let t = [];\n    for (let j=0; j<this.cols; j++) {\n      t[j] = this.state[i][positiveMod(j-dir, this.cols)]\n    }\n    this.state[i] = t;\n  }\n\n  moveVert(x, dir) {\n    const cols = this.colGroup(x);\n    cols.forEach(col => this.moveSingleColVert(col, dir));\n  }\n\n  moveSingleColVert(j, dir) {\n    let t = [];\n    for (let i=0; i<this.rows; i++) {\n      t[i] = this.state[positiveMod(i-dir, this.rows)][j]\n    }\n    for (let i=0; i<this.rows; i++) {\n      this.state[i][j] = t[i];\n    }\n  }\n}\n\nclass Difficulty {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nmodule.exports = { Puzzle, Difficulty }\n\n\n//# sourceURL=webpack://sliding_puzzle/./puzzle.js?");

/***/ }),

/***/ "./utils.js":
/*!******************!*\
  !*** ./utils.js ***!
  \******************/
/***/ ((module) => {

eval("/**\n * Like modulo, but always returns a positive value.\n */\nfunction positiveMod(n, d) {\n  const r = n % d;\n  return (r < 0) ? r + Math.abs(d) : r;\n}\n\n/**\n * Returns an integer in [0,n-1].\n */\nfunction randInt(n) {\n  let i = Math.floor(Math.random() * n);\n  return i;\n}\n\nmodule.exports = { positiveMod, randInt }\n\n\n//# sourceURL=webpack://sliding_puzzle/./utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;